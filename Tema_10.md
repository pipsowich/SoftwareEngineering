# Тема 10. Декораторы и исключения
Отчет по Теме #10 выполнил:
- Кайгородов Олег Юрьевич
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ |---------|---------|
| Задание 1 | +       | +       |
| Задание 2 | +       | +       |
| Задание 3 | +       | +       |
| Задание 4 | +       | +       |
| Задание 5 | +       | +       |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Наверняка вы думаете, что декораторы – это какая-то бесполезная
### вещь, которая вам никогда не пригодится, но тут вдруг на паре по
### математике преподаватель просит всех посчитать число Фибоначчи для
### 100. Кто-то будет считать вручную (так точно не нужно), кто-то
### посчитает на калькуляторе, а кто-то подумает, что он самый крутой и
### напишет рекурсивную программу на Python и немного огорчится,
### потому что данная программа будет достаточно долго считаться, если
### ее просто так запускать. Но именно тут к вам на помощь приходят
### декораторы, например @lru_cache (он предназначен для решения задач
### динамическим программированием, если простыми словами, то этот
### декоратор запоминает промежуточные результаты и при рекурсивном
### вызове функции программа не будет считать одни и те же значения, а
### просто “возьмёт их из этого декоратора”). Вам нужно написать
### программу, которая будет считать числа Фибоначчи для 100 и
### запустить ее без этого декоратора и с ним, посмотреть на разницу во
### времени решения поставленной задачи.
### P.S. при запуске без декоратора можете долго не ждать, для
### наглядности хватит 10 секунд ожидания.

```python
from functools import lru_cache


@lru_cache(None)
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-1.png)

### Выводы

Создали класс “Car” с атрибутами производитель и модель.

## Лабораторная работа №2
### Илья пишет свой сайт и ему необходимо сделать минимальную
### проверку ввода данных пользователя при регистрации. Для этого он
### реализовал функцию, которая выводит данные пользователя на экран и
### решил, что будет проверять правильность введённых данных при
### помощи декоратора, но в этом ему потребовалась ваша помощь.
### Напишите декоратор для функции, который будет принимать все
### параметры вызываемой функции (имя, возраст) и проверять чтобы
### возраст был больше 0 и меньше 130.
### Причем заметьте, что неважно сколько пользователь введет данных на
### сайт к Илье, будут обрабатываться только первые 2 аргумента.

```python
def check(input_func):
    def output_func(*args):
        name, age = args[0], args[1]

        if age < 0 or age > 130:
            age = 'Недопустимый возраст'
        input_func(name, age)

    return output_func


@check
def personal_info(name, age):
    print(f"Name: {name} Age: {age}")

personal_info('Владимир', 38)
personal_info('Александр', -5)
personal_info('Петр', 138, 15, 48, 2)
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-2.png)

### Выводы

добавили метод drive

## Лабораторная работа №3
### Вам понравилась идея Ильи с сайтом, и вы решили дальше работать
### вместе с ним. Но вот в вашем проекте появилась проблема, кто-то
### пытается сломать вашу функцию с получением данных для сайта. Эта
### функция работает только с данными integer, а какой-то недохакер
### пытается все сломать и вместо нужного типа данных отправляет string.
### Воспользуйтесь исключениями, чтобы неподходящий тип данных не
### ломал ваш сайт.
### Также дополнительно можете обернуть весь код функции в
### try/except/finally для того, чтобы программа вас оповестила о том, что
### выявлена какая-то ошибка или программа успешно выполнена.

```python
def data(*args):
    try:
        for i in range(len(*args)):
            try:
                result = (args[0][i] * 15) // 10
                print(result)
            except Exception as ex:
                print(ex)
    except Exception as ex:
        print(ex)
    finally:
        print('Вся информация обработана')

data([1, 15, 'Hello', 'i', 'try', 'to', 'crash', 'your', 'site', 38, 45])
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-3.png)

### Выводы

Создали новый класс “ElectricCar” с методом “charge” и атрибутом емкость батареи
  
## Лабораторная работа №4
### Продолжая работу над сайтом, вы решили написать собственное
### исключение, которое будет вызываться в случае, если в функцию
### проверки имени при регистрации передана строка длиннее десяти
### символов, а если имя имеет допустимую длину, то в консоль
### выводиться “Успешная регистрация”

```python
class NegativeValueException(Exception):
    pass

def check_name(name):
    if len(name) > 10:
        raise NegativeValueException('Длина более 10 символов')
    else:
        print('Успешная регистрация')

name = '123456788910'
check_name(name)
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-4.png)

### Выводы

добавили инкапсуляцию, сделав атрибуты приватными

## Лабораторная работа №5
### После запуска сайта вы поняли, что вам необходимо добавить логгер,
### для отслеживания его работы. Готовыми вариантами вы не захотели
### пользоваться, и поэтому решили создать очень простую пародию. Для
### этого создали две функции: __init__() (вызывается при создании класса
### декоратора в программе) и __call__() (вызывается при вызове
### декоратора). Создайте необходимый вам декоратор. Выведите все логи
### в консоль.



```python
class SiteChecker:
    def __init__(self, func):
        print('> Класс SiteChecker метод __init__ успешный запуск')
        self.func = func

    def __call__(self):
        print('> Проверка перед запуском', self.func.__name__)
        self.func()
        print('> Проверка безопасного выключения')


@SiteChecker
def site():
    print('Усердная работа сайта')

print('>> Сайт запущен')
site()
print('>> Сайт выключен')
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-5.png)

### Выводы

добавили два класса наследника, где переопределили метод area, таким образом применив полиморфизм

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны
### отличаться, от тех, что указаны в теоретическом материале
### (методичке) и лабораторных заданиях. Результатом выполнения
### задания будет листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self, hp):
        self.hp = hp

    def get_hp(self):
        return self.hp

my_animal = Animal(5)
print(my_animal.get_hp())
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-6.png)

### Выводы

1. `class Animal:` создаем класс Animal
2. `def __init__(self, hp):` конструктор класса
3. `my_animal = Animal(5)` создаем объект класса
  
## Самостоятельная работа №2
### Самостоятельно создайте атрибуты и методы для ранее созданного
### класса. Они должны отличаться, от тех, что указаны в
### теоретическом материале (методичке) и лабораторных заданиях.
### Результатом выполнения задания будет листинг кода и
### получившийся вывод консоли.

```python
class Animal:
    def __init__(self, hp, voice):
        self.hp = hp
        self.voice = voice

    def get_hp(self):
        return self.hp

    def say(self):
        return self.voice

my_animal = Animal(5, "я животное")
print(my_animal.get_hp())
print(my_animal.say())
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-7.png)

### Выводы

1. `def __init__(self, hp, voice):` добавил атрибут voice (голос)
2. `def say(self):` добавил метод say, который возвращает voice
  
## Самостоятельная работа №3
### Самостоятельно реализуйте наследование, продолжая работать с
### ранее созданным классом. Оно должно отличаться, от того, что
### указано в теоретическом материале (методичке) и лабораторных
### заданиях. Результатом выполнения задания будет листинг кода и
### получившийся вывод консоли.


```python
class Animal:
    def __init__(self, hp):
        self.hp = hp
        self.voice = "я животное"

    def get_hp(self):
        return self.hp

    def say(self):
        return self.voice

class Dog(Animal):
    def __init__(self, hp):
        super().__init__(hp)
        self.voice = "гав!"

my_animal = Animal(5)
my_dog= Dog(10)

print(my_animal.say())
print(my_dog.say())
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-8.png)

### Выводы

1. `class Dog(Animal):` создаем класс Dog у наследуемый от класса Animal
2. `super().__init__(hp)` передаем аргумент в конструктор родительского класса
3. `self.voice = "гав!"` переопределяем voice 
4. `my_dog= Dog(10)` создаем объект класса Dog
  
## Самостоятельная работа №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с
### ранее созданным классом. Она должна отличаться, от того, что
### указана в теоретическом материале (методичке) и лабораторных
### заданиях. Результатом выполнения задания будет листинг кода и
### получившийся вывод консоли.

```python
class Animal:
    def __init__(self, hp):
        self.__hp = hp  
        self.voice = "я животное"

    def get_hp(self):
        return self.__hp

    def set_hp(self, new_hp):
        if new_hp >= 0:  
            self.__hp = new_hp
        else:
            print("Значение здоровья не может быть отрицательным")

    def say(self):
        return self.voice

class Dog(Animal):
    def __init__(self, hp):
        super().__init__(hp)
        self.voice = "гав!"

my_animal = Animal(5)
my_dog = Dog(10)

print(my_animal.say())  
print(my_dog.say())      

print(my_animal.get_hp())  
my_animal.set_hp(8)       
print(my_animal.get_hp())  
my_animal.set_hp(-3)
```
### Результат.

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-9.png)

### Выводы

1. `self.__hp = hp` делаем hp приватным
2. `def get_hp(self):` добавляем геттер
3. `def set_hp(self, new_hp):` добавляем сеттер
  
## Самостоятельная работа №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и
### лабораторных заданиях. Результатом выполнения задания будет
### листинг кода и получившийся вывод консоли.

```python
class Animal:
    def __init__(self, hp):
        self.__hp = hp  

    def get_hp(self):
        return self.__hp

    def set_hp(self, new_hp):
        if new_hp >= 0:
            self.__hp = new_hp
        else:
            print("Значение здоровья не может быть отрицательным")

    def say(self):
        return "я животное" 


class Dog(Animal):
    def __init__(self, hp):
        super().__init__(hp)

    def say(self):
        return "гав!"  


class Cat(Animal):
    def __init__(self, hp):
        super().__init__(hp)

    def say(self):
        return "мяу!"  

animals = [Animal(5), Dog(10), Cat(8)]

for animal in animals:
    print(animal.say())  
```

### Результат.

![Меню]([images/s-task5.png](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/10-10.png))

### Выводы

переопределяем метод say в Dog и Cat, таким образом получаем полиморфизм

## Общие выводы по теме
Базово освоил работу в ооп стиле на python. А если точнее познакомился с классами, их конструкторами, полиморфизмом и инкапсуляцией, а также наследованием
