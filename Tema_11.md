# Тема 11. Итераторы и генераторы
Отчет по Теме #11 выполнил(а):
- Кайгородов Олег Юрьевич
- ПИЭ-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | - |
| Задание 4 | + | - |
| Задание 5 | + | - |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1

Простой итератор, но у него нет гибкой настройки, например его нельзя развернуть. Он работает просто как next(), но нет prev()

```python
numbers = [0, 1, 2, 3, 4, 5]
for item in numbers:
    print(item)
```
### Результат.

![image](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_1.png)

## Выводы

Создадим цикли(значения от 0 до 5), затем по нему пробежимся и выведем каждый элемент а экран.

## Лабораторная работа №2

Класс итератор с гибкой настройкой и удобными применением

```python
class CountDown:
    def __init__(self, start):
        self.count = start + 1
    def __iter__(self):
        return self
    def __next__(self):
        self.count -= 1
        if self.count < 0:
            raise StopIteration
        return self.count

if __name__ == '__main__':
    counter = CountDown(5)
    for i in counter:
        print(i)
```
### Результат.

![image](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_2.png)

## Выводы

Создание класса CountDown, он позволяет выполнять обратный отсчет от полученного им числа.
В код также включен цикл выводящий все числа обратного отчета на экран.

## Лабораторная работа №3

Генератор списка

```python
a = [i ** 2 for i in range(1, 5)]
print('a - ', a)
for i in a:
    print(i)
print('iter(a) - ', iter(a))
for i in a:
    print(i)
```
### Результат.

![image](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_3.png)

## Выводы
С помощью спискового включения (list comprehension) создается список a, который содержит квадраты чисел от 1 до 4 (включительно).

Далее выводит этот список на экран при помощи print.

При помощи цикла for проходимся по каждому элементу списка a и выводит его на экран.

после этого создаем итератор для списка a с помощью функции iter() и выводит его на экран.

В самый конец снова проходимся по элементам списка a и выводим их на экран.

## Лабораторная работа №4

Выражения генераторы

```python
b = (i ** 2 for i in range(1, 5))
print(b)
print('first')
for i in b:
    print(i)
print('second')
for i in b:
    print(i)
```
### Результат.

![image](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_4.png)

## Выводы

Инициализируем переменную b генераторным выражением, которое вычисляет квадрат каждого числа в диапазоне от 1 до 4. Но в отличие от списка, генератор не создает все значения сразу, а генерирует их по мере необходимости.

При первом вызове print(b) выводится информация о самом генераторе, а не его значениях. Это показывает, что b является объектом генератора.

Затем выполняется цикл for, который проходит по элементам генератора b, и для каждого элемента (квадрату числа) выводит его на экран. После первой итерации генератор "истощается", и все значения уже были сгенерированы и выведены.

Когда выполняется второй цикл for, он пытается снова пройти по генератору b. Однако так как генератор уже был использован в первой итерации и не может быть использован повторно, в результате ничего не выводится.

## Лабораторная работа №5

Такой же счетчик, как и в первом задании, только это генератор и использует yield

```python
def countdown(count):
    while count >= 0:
        yield count
        count -= 1
if __name__ == '__main__':
    counter = countdown(5)
    for i in counter:
        print(i)
```
### Результат.

![image](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_5.png)

## Выводы

Функция countdown(count) - генераторная функция, которая принимает один аргумент — count. Внутри функции используется цикл while, который продолжает выполняться, пока значение count не станет меньше нуля.

yield count - каждое значение count возвращается с помощью ключевого слова yield. Это означает, что функция не завершает свое выполнение, а приостанавливается и запоминает текущее состояние, позволяя продолжить выполнение при следующем вызове.

После того как текущее значение count было возвращено, оно уменьшается на 1, и цикл продолжается.

В следущующем блоке код проверяет, запущен ли файл непосредственно (а не импортирован как модуль). Если это так, создается экземпляр генератора counter, который начинает с 5.

Цикл for i in counter - этот цикл проходит по значениям, которые генерирует генератор counter, и выводит каждое значение на экран. Таким образом, на экране будут напечатаны числа от 5 до 0.

## Самостоятельная работа №1

### Вас никак не могут оставить числа Фибоначчи, очень уж они вас заинтересовали. Изучив новые возможности Python вы решили реализовать программу, которая считает числа Фибоначчи при помощи итераторов. Расчет начинается с чисел 1 и 1. Создайте функцию fib(n), генерирующую n чисел Фибоначчи с минимальными затратами ресурсов. Для реализации этой функции потребуется обратиться к инструкции yield (Она не сохраняет в оперативной памяти огромную последовательность, а дает возможность “доставать” промежуточные результаты по одному). Результатом решения задачи будет листинг кода и вывод в консоль с числом Фибоначчи от 200.

```python
def fib(n):
    a, b = 1, 1
    for num in range(n):
        yield a
        a, b = b, a + b

# Генерируем числа Фибоначчи и выводим 200-е число
n = 300
fibonacci_numbers = list(fib(n))

print(f"{n}-е число Фибоначчи: {fibonacci_numbers[-1]}")
```

### Результат

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_6.png)

### Выводы

Функция fib(n) принимает одно целое число n, которое указывает, сколько чисел Фибоначчи нужно сгенерировать.

Внутри функции используются две переменные a и b, которые инициализируются значениями 1 и 1 (первые два числа Фибоначчи).

Цикл for выполняется n раз. На каждой итерации:
   
   • Используется yield, для вовзращения текущего значения a.
   
   • Затем обновляются значения a и b для следующей итерации.

После вызова функции fib(n), результат преобразуется в список, чтобы получить доступ к элементам по индексу.

## Самостоятельная работа №2
### К коду предыдущей задачи добавьте запоминание каждого числа Фибоначчи в файл “fib.txt”, при этом каждое число должно находиться на отдельной строчке. Результатом выполнения задачи будет листинг кода и скриншот получившегося файла

```python
def fib(n):
    a, b = 1, 1
    with open('fib.txt', 'w') as f:
        for _ in range(n):
            f.write(f"{a}\n")
            yield a
            a, b = b, a + b

n = 300
fibonacci_numbers = list(fib(n))

print(f"{n}-е число Фибоначчи: {fibonacci_numbers[-1]}")
```

### Результат

![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_7.png)
![Меню](https://github.com/pipsowich/SoftwareEngineering/blob/main/Imagies/11_7_1.png)

### Выводы
Внутри функции fib(n) добавлена конструкция with open('fib.txt', 'w') as f, которая открывает файл fib.txt для записи (если файл не существует, он будет создан).

Внутри цикла for добавлена строка f.write(f"{a}\n"), которая записывает текущее число Фибоначчи в файл, добавляя перевод строки после каждого числа.
  
## Общие выводы по теме

Итераторы (iterators) -  объекты в Python, которые позволяют последовательно обходить элементы в какой-либо структуре данных, например, в списке, кортеже, множестве или строке

Генераторы в Python - специальный тип функций или выражений, которые позволяют создавать итераторы более эффективным способом. Генераторы позволяют генерировать значения последовательно по одному элементу за раз без необходимости хранения всей последовательности в памяти.

Генераторные выражения (generator expressions) в Python - компактный и эффективный способ создания генераторов без явного определения функции с использованием ключевого слова yield. Генераторные выражения позволяют создавать итераторы для обработки последовательностей данных на лету, что экономит память и упрощать код

Плюсы использования генераторов:
- экономия памяти
- эффективная обработка больших данных
- ленивая итерация
- удобство и компаткность 
